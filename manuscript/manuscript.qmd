---
title: "The FAIRification of pharmacoepidemiological research: A practical introduction to reproducible analytic workflows using git and R"

code-fold: false
eval: false
echo: true
number-sections: true

format: 
  docx:
    reference-doc: custom-reference-doc.docx
    fig-cap-location: top

editor: visual
bibliography: references.bib
csl: pharmacoepidemiology-and-drug-safety.csl
---

```{r setup}
#| label: setup
#| include: false
#| eval: true
library(magick)
library(cowplot)
library(here)
```

**Authors**: Janick Weberpals^1^, Shirley V. Wang^1^

**Author affiliation**: ^1^Division of Pharmacoepidemiology and Pharmacoeconomics, Department of Medicine, Brigham and Women's Hospital, Harvard Medical School, Boston, MA

[**Correspondence:**]{.underline}

Janick Weberpals, RPh, PhD

Division of Pharmacoepidemiology and Pharmacoeconomics,

Department of Medicine, Brigham and Women's Hospital, Harvard Medical School,

1620 Tremont Street, Suite 3030-R, Boston, MA 02120, USA

Phone: 617-278-0932

Fax: 617-232-8602

Email: [jweberpals\@bwh.harvard.edu](mailto:jweberpals@bwh.harvard.edu)

[**Word count:**]{.underline} xxxx words

[**Tables:**]{.underline} 0

[**Figures:**]{.underline} 6

[**Supplementary material:**]{.underline}

[**Keywords:**]{.underline} Transparency, Reproducibility, Git, R, Version control, Real-world evidence

[**Funding:**]{.underline} There was no specific funding for this manuscript.

[**Disclosures/COI:**]{.underline} Janick Weberpals reports no conflicts of interest.

[Analytical code sharing statement:]{.underline} This manuscript was written using `Quarto` version 1.3.353 (<https://quarto.org/>) and R version 4.1.2. All materials can be found at <https://gitlab-scm.partners.org/drugepi/fair-epi>. Detailed information on packages and versions can be found in the `renv.lock` file in the linked repository.

[**Acknowledgments:**]{.underline} The authors would like to thank ...

{{< pagebreak >}}

# Abstract {.unnumbered}

**Objective**

**Study Design and Settings**

**Results**

**Conclusions**

{{< pagebreak >}}

# Introduction

Transparency and reproducibility in conducting healthcare database studies in pharmacoepidemiology are critical scientific requirements for meaningful research. While many advances have been made in the documentation and reporting of study protocols and results[@wang2021; @schneeweiss2019; @berger2017; @wang2022], the transparency around the actual implementation and analytical steps is still significantly lacking, especially when analyses are implemented via line programming steps in statistical programming languages like R[@RCore2023] or Python. Although in other quantitative disciplines such as computational biology[@almugbel2017; @mammoliti2021; @russell2018] or health informatics[@bakken2019], the sharing of programming code is rather the rule than the exception, this practice is not as common in the (pharmaco-)epidemiological community.

Version control systems (VCS), such as *Git*, can thereby provide easy and powerful tools to keep track of the versioning of important files and documents such as protocols, analytical code, tables and figures. Thereby, it can extend the principles of *FAIR* *data*[@garcía-closas2023] to the implementation of pharmacoepidemiological study workflows by making all components of a study **F**indable, **A**ccessible, **I**nteroperable, and **R**eproducible (**FAIR**).

VCS enable researchers to track and resolve errors, collaborate with peers, and share resources instantaneously, for example, upon submission or publication of a manuscript. By design, VCS workflows automatically empower users to comment, track and compare changes made to files and hence, increase the ability to comprehend the evolution of a project over time while maintaining a complete audit trail of all documents.[@ram2013] Without VCS, this is often naturally done by assigning uninformative file names such as "*final_analysis_1_rev_more_changes.R*" which is bad practice as this is highly error prone, lacking transparency for collaborating project members and outside personnel, and changes are difficult to track and reconcile. Particularly in disciplines like pharmacoepidemiology, where analyses can have far reaching impact on healthcare decisions, analytical code needs to be accessible and reproducible by anyone, not only the analyst who originally carried out the analysis.

To increase the adoption of transparent and reproducible workflows in real-world evidence (RWE) studies using VCS, this tutorial aims to give a practical introduction tailored for pharmacoepidemiologists on how to set up, structure, and implement workflows using *Git*, which is the most frequently used VCS to date.[@blischak2016] We will first give a brief introduction to Git and how it can be used for collaboration and dissemination of study results using project repositories. Then we will provide a technical step-by-step guidance on how to integrate Git in an analytic workflow. We will additionally discuss and showcase important aspects of reproducibillity using the R open-source programming language, although the basic principles are applicable to any major coding language.

{{< pagebreak >}}

# Git in a nutshell

Git is a free and open source distributed VCS software which was developed in 2005 by the LINUX developer community primarily with the intent to handle large software projects efficiently.[@chacon2014pro] The way to conceptually think about how Git works is that it makes a *snapshot* of a research project repository every time the state of a project is saved. For our purposes, a repository can be seen as an isolated project directory which includes all neccessary files and documents for a given research study ( e.g., protocol, programming code, manuscript, tables, figures, etc.).

In its basic form, Git is a local software and does not need any internet connectivity or connection to a remote server to store *local* changes made to files in a repository. However, to leverage the full potential of Git, it is almost always used in combination with web-based remote repository hosting services such as *GitHub*, *GitLab*, *Bitbucket* or other platforms (henceforth referred to as remote repositories, **Overview Box 1**).

::: callout-tip
## **Overview Box 1**. Differences between Git and remote repository platforms (GitHub, GitLab, etc.)

**Git**

-   Is an open-source software and distributed version control system

-   Generally operated through command line tools, graphical user interfaces are available

-   Installed locally on a system to track local changes of a Git repository

**Remote repository platforms (GitHub, GitLab, etc.)**

-   Web-based services, usually provided by a commercial entity

-   Usually free for basic functions, paid services for more advanced features

-   Needed to collaborate on shared repositories and dissemination of code

-   Offer a graphical user interface and other functionalities that complement basic Git functions
:::

These platforms make it possible to synchronize local Git repositories across multiple project members and thereby improve collaboration. They further complement Git functionalities by providing a graphical user interface (GUI) to visualize changes made to files and often offer advanced features such as the automation of workflows using continuous integration and deployment (CI/CD) or, most recently, AI-powered virtual coding assistants (e.g., GitHub co-pilot). Generally speaking, it's possible to use Git without a remote repository, while it's unusual to use a remote repository without Git.

# A step-by-step introduction on how to use Git in a pharmacoepidemiology research study

In this section, we want to give a technical introduction on how Git and remote repositories can be used in RWE studies. For the following examples, we focus on workflows utilizing R/RStudio ([https://posit.co/download/rstudio-desktop/](https://posit.co/download/rstudio-desktop/https://posit.co/download/rstudio-desktop/)) and GitHub (<https://github.com/>) as remote repository, although the general concepts are fairly similar and easily transferable to other programming languages and remote repository providers, respectively. We will show examples for both command line interface (CLI) prompts as well as for RStudio's integrated GUI. For more details, we refer to the book *Pro Git* by Chacon and Straub.[@chacon2014pro] 

## Installing Git

Git is available for every contemporary operating system and can be downloaded on the official Git website: <https://git-scm.com/book/en/v2/Getting-Started-Installing-Git>.

To check if the installation succeeded and show the available version, the following prompt in the CLI can be used.

```{bash}
git --version
```

## Configuration and first time use

For Git to be able to track who made changes, the first step is to provide a name and email address as shown below. This needs to be done only once if the `--global` parameter is set.

```{bash}
git config --global user.name "First Last"
git config --global user.email "name@domain.edu"
```

## Initialization of a new Git-controlled repository

### Local initialization

To start a new project (e.g., a new RWE study), the next step is to create and navigate to a new directory where all documents that are intended to be tracked via Git will be stored (in the following referred to as *repository*). In this example, the study repository is called `rwe_study`.

```{bash}
mkdir ~/rwe_study
cd ~/rwe_study
```

The command to initialize this directory as a Git repository is

```{bash}
git init
```

This initiates the creation of the `.git` sub-directory within the study repository which will contain the entire version history of the `rwe_study` project. Typically, users don't directly interact with this sub-directory and the only thing to keep in mind is that this folder keeps all files needed to track changes.

### GUI initialization and `git clone` {#sec-gui-initialization-and-git-clone}

An alternative to creating a new repository locally is through creating a new project in the remote repository (in this case GitHub) and then creating a local copy, a process which is usually referred to as `cloning`.

To do so, users will need to log into their remote repository account and navigate to the section `New repository` (**Supplementary Figure 1**). This will take a user to a form to populate basic information of the new project such as the repository name (`rwe_study`) and choose basic setting such as if the repository should be private or public and if a `README.md` (see @sec-repository-structure) and `.gitignore` (see @sec-stage-and-commit-changes) file should be automatically created (**Supplementary Figure 2**).

Now we can copy the pre-populated repository to our local machine by copy-pasting the link given under `Clone` \> `Copy HTTPS` into the CLI (**Supplementary Figure 3**):

```{bash}
mkdir ~/rwe_study
cd ~/rwe_study
git clone  https://gitlab.com/USERNAME/rwe_study.gitlab.io.git
```

This can also be achieved directly in the RStudio GUI via `File` \> `New Project` \> `Version Control` \> `Git` \> paste the link to `Repository URL` (@fig-RStudio-gui).

## Repository structure {#sec-repository-structure}

At this step, we now can populate the repository and start working on study-relevant documents. To enhance clarity, it is recommended to use a logical structure and informative and transparent sub-directory and file names (a minimal example is illustrated in @fig-structure). To document the structure and location of files, we can include this and other critical information, that a peer or outside personnel should know concerning the project, in the `README.md` file. This file can be auto-generated when a project is initialized in a remote repository (see prior step in @sec-gui-initialization-and-git-clone) or can be added manually aftwerwards by creating and adding a text file with the name `README.md` in the root directory of the repository.

To speed up these initial steps, we provide a pre-populated template of such a structured study repository based on the HARPER protocol[@wang2022] under <https://gitlab-scm.partners.org/drugepi/harper>.

## The git workflow

The most essential steps of a git workflow are summarized in @fig-workflow.

### Stage and commit changes {#sec-stage-and-commit-changes}

As introduced before, Git allows researchers to keep track of changes by making snapshots of the repository every time the state of a project is saved. In Git terms, this fundamental step is referred to as a `commit`. Generally it is up to the user when to commit, which files to commit and how the commit should be documented in a `commit message`.

To determine which files should be selected (or `staged`) for a new commit, the `git add` command is used followed by the name(s) of the files that should be committed or a '`.'` to stage all changes present in the current repository.

```{bash}
# Examplary staging command
git add 'scripts/03_propensity_score_analysis.R'
```

Once all files that should be committed in the same step are staged, the `git commit` command will create a local snapshot of the changes. The `-m` suffix and quoted text after the command represent the commit message, i.e., an informative yet brief comment on what changes were performed.

```{bash}
# Examplary commit command
git commit -m 'added title to plot illustrating propensity score overlap'
```

Every time a user makes a commit to create a snapshot of the work, `Git` creates a unique hash (a 40-character string created by a **simple hashing algorithm** \[SHA\]) which can be seen as an "ID" of the snapshot which enables user to comprehend every change made and revert back to any snapshot of the repository. @fig-stage-commit-RStudio-gui illustrates the equivalent step by using the RStudio GUI.

If any file(s) in the study repository should not be tracked and hence not be synchronized with the remote repository (e.g., because they include confidential information that should not be visible to others like database credentials), these files can be specified in the `.gitignore` file which needs to be located in the root directory of the repository. To create a `.gitignore` file, either auto-generate it upon initialization of the repository on GitHub (**Supplementary Figure 2**) or manually add a text file called `.gitignore` to the root directory.

## Synchronize changes with remote repository

### Synchronize local changes to remote (`push`)

To synchronize the local changes made to our files, the next step involves synchronizing our commits with the remote repository on GitHub via the `push` command.

```{bash}
git push
```

In case we initialized the local repository as described in section @sec-gui-initialization-and-git-clone, a remote was automatically configured. This can be checked via the following command.

```{bash}
git remote -v
```

If there is no remote established yet, this can be configured using the following commands.

```{bash}
git remote add origin https://github.com/USERNAME/rwe_study.git
git branch -M main
git push -u origin main
```

This step is not needed if the intention of a researcher is just to keep track of local changes and there is no wish to share code, collaborate with others or work across different systems. However, most of the times researchers intentionally use `Git` to collaborate on a project and remote repositories such as GitHub as this can improve collaborative work significantly (@fig-collaborate).

### Synchronize remote to local (`pull`)

In case collaborators have also made modification to their local files and pushed them to the remote repository, these changes can be easily synchronized with our local copy via the `pull` command.

```{bash}
git pull
```

Occasionally it can occur that two collaborators made conflicting changes to the same file or even to the same line of code. While Git is generally good at automatically integrating (`merging`) new changes, Git will notify the user to resolve a major conflict by editing the conflicting file if Git cannot automatically determine what is correct ((e.g., when one collaborator has made changes to a line of code and the other completely deleted it).

## Tracking changes

One of the main motivations to adhere to this workflow is that in return we get rewarded with a detailed audit trail of changes made to our files. Probably, the best way to visualize and track changes is by browsing the `commit history` on the remote repository. @fig-GitHub-gui_changes illustrates this for the example commit we have previously performed in @sec-stage-and-commit-changes. A similar view for uncommitted changes is also provided in the RStudio GUI as displayed in @fig-stage-commit-RStudio-gui.

For completeness, tracking uncommitted changes is also possible via the command line, but usually provides the user with a less intuitive output compared to what is visually provided by RStudio and GitHub.

```{bash}
git diff
```

A complete summary of committed changes with details on SHA hash, author, email, time and commit messages can be accessed via

```{bash}
git log
```

## Keeping track of R software versions and paths

A major advantage of modern programming languages, is that they provide a large pool of open-source packages. Packages are compilations of functions that automate frequently used procedures (e.g., querying new user cohorts[@tidyverse] or propensity score matching[@MatchIt]) which expedites the implementation of RWE studies, mitigates copy-paste errors and makes code much more friendly to read and review.

A further step to improve reproducibility when using the R programming language is to ensure that anyone intending to reproduce analytic results from a `Git` repository is able to work off the same R package versions and dependencies without having to perform manual installations or path adjustments. These requirements are nothing exclusive to R, but apply to any type of programming language.

### Reproducible R computing environments

One way to achieve this is through self-contained computing environments via Docker images which are isolated and standardized environments which include everything needed to run and deploy applications and code regardless of a user's local operating system.[@boettiger2017a; @nüst2020] Another more lightweight, yet effective way is by using the `renv` R package[@renv], which helps creating **re**producible **env**ironments and manages R package dependencies for a given project. Through a lockfile, the `renv` package keeps track of the underlying version of R that is being used as well as all R packages, their versions and the installation source (e.g., <https://cran.r-project.org/>). To synchronize the R environment with that of a collaborator, e.g., after cloning a repository, all that needs to be done is running the following command in R.

```{r}
renv::restore()
```

Appending the session info to the end of an R script can provide further context.

```{r}
sessionInfo()
```

### Absolute versus relative paths

Another common issue when trying to reproduce analytic code is the use of absolute paths such as in the following example, where we try to call an `icd_code` file from the project's `protocol` sub-directory.

```{r}
icd_codes <- read.csv("C:\Users\Username\Projects\rwe_study\protocol\icd_codes.csv")
```

The use of absolute paths will make it impossible for anyone to run the code without having to manually adapt every single path throughout a repository which is tedious and time consuming. A better solution to this is the use of relative paths. A popular R package to implement this is the `here` package which enables file referencing in project-oriented workflows. The main function "`here"` creates paths relative to the top-level of the project directory (in our example `rwe_study`). Applied to our example project, the following command would automatically reference the correct path and could be used without modification by any user re-running this script.

```{r}
library(here)
icd_codes <- read.csv(here("data", "icd_codes.csv"))
```

# Discussion

Also other GUIs to interact with Git...

Advantages of distributed VCS (Git):

-   Full audit trail of which changes were made by whom, when and why

-   Even if the code is not shared, Git makes it easier for an individual to go back to the code

-   Git can serve as internal and external repository for code and made accessible to everyone, e.g. along with manuscript without copy-paste into word files or similar

-   It is free and open-source and reliable

-   Distributed VCS fully mirror entire repositories and hence every local clone is a full backup of the data

{{< pagebreak >}}

# Figures {.unnumbered}

```{r}
#| label: Fig1
#| fig-cap: "Clone a remote repository using the RStudio graphical user interface."
#| eval: false
#| echo: false

fig1a <- ggdraw() +
  draw_image(image_read(here("figures", "Figure_1a_RStudio.png")))

fig1b <- ggdraw() +
  draw_image(image_read(here("figures", "Figure_1b_RStudio.png")))

fig1c <- ggdraw() +
  draw_image(image_read(here("figures", "Figure_1c_RStudio.png")))

fig1d <- ggdraw() +
  draw_image(image_read(here("figures", "Figure_1d_RStudio.png")))

figure_1 <- plot_grid(
  fig1a, fig1b, fig1c, fig1d,
  nrow = 2,
  ncol = 2,
  #labels = c("a)", "b)", "c)", "d)"),
  hjust = 0.005,
  label_size = 16
  )

png(
  filename = here("figures", "Figure_1_RStudio_init.png"), 
  width = 15, height = 10, units = "in", res=600
  )
figure_1
invisible(dev.off())

knitr::include_graphics(here::here("figures", "Figure_1_RStudio_init.png"))
```

```{r}
#| label: fig-RStudio-gui
#| fig-cap: "Clone a remote repository using the RStudio graphical user interface."
#| eval: true
#| echo: false
#| out-width: 50%
knitr::include_graphics(here::here("figures", "Figure_1_RStudio_init.png"))
```

{{< pagebreak >}}

```{r}
#| label: fig-structure
#| fig-cap: "Minimal example of a transparent repository structure containing relevant study documents"
#| eval: true
#| echo: false
#| out-width: 60%
knitr::include_graphics(here::here("figures", "Figure_2_repo_structure.png"))
```

{{< pagebreak >}}

```{r}
#| label: fig-workflow
#| fig-cap: "Overview of a basic Git workflow."
#| eval: true
#| echo: false
knitr::include_graphics(here::here("figures", "Figure_3_workflow.png"))
```

{{< pagebreak >}}

```{r}
#| label: fig-stage-commit-RStudio-gui
#| fig-cap: "RStudio provides a graphical user interface as an alternative to command line prompts to interact with Git and to perform command equivalent to git add, git commit and git push/pull (red circles). This view can be accessed in the right upper pane of RStudio under Git > Diff. In this example, an R script with the title '03_propensity_score_analysis.R' is selected and staged. All changes performed in this file can be viewed in the window below with green highlighted lines indicating additions and red highlighted lines deletions from the prior version. In this case, a title was added to a propensity score plot which is also expressed in the commit message."
#| eval: true
#| echo: false
knitr::include_graphics(here::here("figures", "Figure_4_stage_commit.png"))
```

{{< pagebreak >}}

```{r}
#| label: fig-collaborate
#| fig-cap: "Git in connection with remote repositories (e.g., GitHub or GitLab) can signficantly improve collaboration across project members."
#| eval: true
#| echo: false
knitr::include_graphics(here::here("figures", "Figure_5_collaboration.png"))
```

{{< pagebreak >}}

```{r}
{r}
#| label: fig-GitHub-gui_changes
#| fig-cap: "Remote repositories like GitHub provide tools to visually track changes made to analytical code and corresponding output such as figures. This commit history illustrates details about the commit (e.g., commit SHA hash and message), a side-by-side comparison of the previous (upper left) and modified (upper right) version of the figure and the corresponding changes made to the R code (bottom)."
#| out-width: 105%

include_graphics(here("figures", "SFigure_4_commit_Github_gui.png"))
```

# References {.unnumbered}
