---
title: "The FAIRification of research in real-world evidence: A practical introduction to reproducible analytic workflows using Git and R"

code-fold: false
eval: false
echo: true
number-sections: true

format: 
  docx:
    reference-doc: custom-reference-doc.docx
    fig-cap-location: top

editor: visual
bibliography: references.bib
csl: pharmacoepidemiology-and-drug-safety.csl
---

```{r setup}
#| label: setup
#| include: false
#| eval: true
library(magick)
library(cowplot)
library(here)
```

**Authors**: Janick Weberpals^1^, Shirley V. Wang^1^

**Author affiliation**: ^1^Division of Pharmacoepidemiology and Pharmacoeconomics, Department of Medicine, Brigham and Women's Hospital, Harvard Medical School, Boston, MA

[**Correspondence:**]{.underline}

Janick Weberpals, RPh, PhD

Division of Pharmacoepidemiology and Pharmacoeconomics,

Department of Medicine, Brigham and Women's Hospital, Harvard Medical School,

1620 Tremont Street, Suite 3030-R, Boston, MA 02120, USA

Phone: 617-278-0932

Fax: 617-232-8602

Email: [jweberpals\@bwh.harvard.edu](mailto:jweberpals@bwh.harvard.edu)

[**Word count:**]{.underline} 3,028 words

[**Tables:**]{.underline} 0

[**Figures:**]{.underline} 6

[**Supplementary material:**]{.underline} Supplementary Appendix and Supplementary Figures (pdf)

[**Short running title**]{.underline}: FAIRification of research in real-world evidence

[**Keywords:**]{.underline} Transparency, Reproducibility, Git, R, Version control, Real-world evidence

[**Funding:**]{.underline} There was no specific funding for this manuscript.

[**Disclosures/COI:**]{.underline} Janick Weberpals reports no conflicts of interest.

[Analytical code sharing statement:]{.underline} This manuscript was written using `Quarto` version 1.3.353 (<https://quarto.org/>) and R version 4.1.2. All materials can be found at <https://gitlab-scm.partners.org/drugepi/fair-epi>. Detailed information on packages and versions can be found in the `renv.lock` file in the linked repository.

[**Acknowledgments:**]{.underline} None.

{{< pagebreak >}}

# Abstract {.unnumbered}

Transparency and reproducibility are major prerequisites for meaningful real-world evidence (RWE) studies. Many advances have been made in the documentation and reporting of study protocols and results, but the version control and sharing of analytic code in RWE is not as established yet as in other quantitative disciplines like computational biology and health informatics. In this practical tutorial, we aim to give an introduction to distributed version control systems (VCS) tailored towards the FAIR (**F**indable, **A**ccessible, **I**nteroperable and **R**eproducible) implementation of RWE studies. To ease adoption, we provide detailed step-by-step instructions with practical examples on how the Git VCS and R programming language can be implemented into RWE workflows to facilitate reproducible analyses. We further discuss and showcase how these tools can be used to track changes, collaborate, disseminate and archive RWE studies through dedicated project repositories maintaining a complete audit trail of all relevant study documents.

{{< pagebreak >}}

# Introduction

Transparency and reproducibility in conducting real-world evidence (RWE) studies are critical scientific requirements for meaningful research. While many advances have been made in the documentation and reporting of study protocols and results[@wang2021; @schneeweiss2019; @berger2017; @wang2022], the transparency around the actual implementation and analytic steps is still significantly lacking, especially when analyses are implemented via line coding in statistical programming languages like R[@RCore2023] or Python. Although in other quantitative disciplines such as computational biology[@almugbel2017; @mammoliti2021; @russell2018] or health informatics[@bakken2019], the sharing of code is rather the rule than the exception, this practice is not as common in the (pharmaco-) epidemiological community.

Version control systems (VCS), such as *Git*, can thereby provide easy and powerful tools to keep track of the versioning of important files and documents such as protocols, analytic code, tables and figures. Thereby, it can extend the principles of *FAIR* *data*[@garcía-closas2023] to the implementation of pharmacoepidemiological study workflows by making all components of a study **F**indable, **A**ccessible, **I**nteroperable, and **R**eproducible (**FAIR**).

VCS enable researchers to track and resolve errors, collaborate with peers, and share resources instantaneously, for example, upon publication of a manuscript. By design, VCS workflows automatically empower users to comment, track and compare changes made to files and hence, increase the ability to comprehend the evolution of a project over time while maintaining a complete audit trail of all documents.[@ram2013] Without VCS, this is often naturally done by assigning uninformative file names such as "*final_analysis_1_rev_more_changes.R*" which is bad practice as this is highly error prone, lacking transparency for collaborators, and changes are difficult to track and reconcile. Particularly in disciplines like pharmacoepidemiology, where analyses can have far reaching impact on healthcare decisions, analytic code needs to be accessible and reproducible.

To increase the adoption of transparent and reproducible workflows in RWE studies using VCS, this tutorial aims to give a practical introduction for pharmacoepidemiologists on how to set up, structure, and implement workflows using *Git*, which is the most popular VCS to date.[@blischak2016] We will first give a brief introduction to Git and its usage for collaboration and dissemination of study results through project repositories. Then we will provide a technical step-by-step guidance on how to integrate Git in analytic RWE workflows. We will additionally discuss and showcase important aspects of reproducibillity using the R open-source programming language, although the basic principles are applicable to any major coding language.

{{< pagebreak >}}

# Git in a nutshell

Git is a free and open source distributed VCS software which was developed in 2005 by the LINUX developer community primarily with the intent to handle large software projects efficiently.[@chacon2014pro] The way to conceptually think about how Git works is that it makes a *snapshot* of a research project repository every time the state of a project is saved. For our purposes, a repository can be seen as an isolated project directory which includes all neccessary files and documents for a given research study ( e.g., protocol, programming code, manuscript, tables, figures, etc.).

In its basic form, Git is a local software and does not need any internet connectivity or connection to a remote server to store *local* changes made to files in a repository. However, to leverage the full potential of Git, it is almost always used in combination with web-based remote repository hosting services such as *GitHub*, *GitLab*, *Bitbucket* or other platforms (henceforth referred to as remote repositories, **Overview Box 1**).

::: callout-tip
## **Overview Box 1**. Differences between Git and remote repository platforms (GitHub, GitLab, etc.)

**Git**

-   Is an open-source software and distributed version control system

-   Generally operated through command line tools, graphical user interfaces are available

-   Installed locally on a system to track local changes of a Git repository

**Remote repository platforms (GitHub, GitLab, etc.)**

-   Web-based services, usually provided by a commercial entity

-   Usually free for basic functions, paid services for more advanced features

-   Needed to collaborate on shared repositories and dissemination of code

-   Offer a graphical user interface and other functionalities that complement basic Git functions
:::

These platforms make it possible to synchronize local Git repositories across multiple project members and thereby improve collaboration. They further complement Git functionalities by providing a graphical user interface (GUI) to visualize changes made to files and often offer advanced features such as the automation of workflows using continuous integration and deployment (CI/CD) or, most recently, AI-powered virtual coding assistants (e.g., GitHub co-pilot). Generally speaking, it's possible to use Git without a remote repository, while it's unusual to use a remote repository without Git.

# A step-by-step introduction on how to use Git in a RWE study

In this section, we want to give a technical introduction on how Git and remote repositories can be used in RWE studies. For the following examples, we focus on workflows utilizing R/RStudio ([https://posit.co/download/rstudio-desktop/](https://posit.co/download/rstudio-desktop/https://posit.co/download/rstudio-desktop/)) and GitHub (<https://github.com/>) as remote repository, although the general concepts are fairly similar and easily transferable to other programming languages and remote repository providers, respectively. We will show examples for both command line interface (CLI) prompts as well as for RStudio's integrated GUI. For more details, we refer to the book *Pro Git* by Chacon and Straub.[@chacon2014pro] 

## Installing Git

Git is available for every contemporary operating system and can be downloaded on the official Git website: <https://git-scm.com/book/en/v2/Getting-Started-Installing-Git>.

To check if the installation succeeded, the following prompt in the CLI can be used, which will output the available version.

```{bash}
git --version
```

## Configuration and first time use

For Git to be able to track who made changes, the first step is to provide a name and email address as shown below. This needs to be done only once if the `--global` parameter is set.

```{bash}
git config --global user.name "First Last"
git config --global user.email "name@domain.edu"
```

## Initialization of a new Git-controlled repository

### Local initialization

To start a new project (e.g., a new RWE study), the next step is to create and navigate to a new directory where all documents that are intended to be tracked via Git will be stored (in the following referred to as *repository*). In this example, the study repository is called `rwe_study`.

```{bash}
mkdir ~/rwe_study
cd ~/rwe_study
```

The command to initialize this directory as a Git repository is

```{bash}
git init
```

This initiates the creation of the `.git` sub-directory within the study repository which will contain the entire version history of the `rwe_study` project. Typically, users don't directly interact with this sub-directory and the only thing to keep in mind is that this folder keeps all files needed to track changes.

### GUI initialization and `git clone` {#sec-gui-initialization-and-git-clone}

An alternative to creating a new repository locally is through initiating a new project in the remote repository (in this case GitHub) and then creating a local copy, a process which is usually referred to as `cloning`.

To do so, users will need to log into their remote repository account and navigate to the section `New repository` (**Supplementary Figure 1**). This will take a user to a form to populate basic information of the new project such as the repository name (`rwe_study`) and choose basic settings such as if the repository should be private or public and if `README.md` (see @sec-repository-structure) and `.gitignore` (see @sec-stage-and-commit-changes) files should be automatically created (**Supplementary Figure 2**).

Now we can copy the pre-populated repository to our local machine by copy-pasting the link given under `Clone` \> `Copy HTTPS` into the CLI (**Supplementary Figure 3**):

```{bash}
mkdir ~/rwe_study
cd ~/rwe_study
git clone  https://gitlab.com/USERNAME/rwe_study.gitlab.io.git
```

This can also be achieved directly in the RStudio GUI via `File` \> `New Project` \> `Version Control` \> `Git` \> paste the link to `Repository URL` (@fig-RStudio-gui).

## Repository structure {#sec-repository-structure}

At this step, we now can populate the repository and start working on study-relevant documents and analyses. To enhance clarity, it is recommended to use a logical structure and an informative nomenclature for sub-directories and file names (a minimal example is illustrated in @fig-structure). To document the structure and location of files, we can include this, and other critical information about the project, in the `README.md` file. This file can be auto-generated when a project is initialized through a remote repository (see prior step in @sec-gui-initialization-and-git-clone) or can be manually added aftwerwards by creating a text file with the name `README.md` in the root directory of the repository.

To speed up these initial steps, we provide a pre-populated template of such a structured study repository based on the HARPER protocol[@wang2022] under <https://gitlab-scm.partners.org/drugepi/harper>.

## The git workflow

The most essential steps of a git workflow are summarized in @fig-workflow.

### Stage and commit changes {#sec-stage-and-commit-changes}

As introduced before, Git allows researchers to keep track of changes by making snapshots of the repository every time the state of a project is saved. In Git terms, this fundamental step is referred to as a `commit`. Generally it is up to the user when to commit, which files to commit and how the commit should be documented in a `commit message`.

To determine which files should be selected (or `staged`) for a new commit, the `git add` command is used followed by the name(s) of the files that should be committed or a '`.'` to stage all changes present in the current repository.

```{bash}
# Examplary staging command
git add 'scripts/03_propensity_score_analysis.R'
```

Once all files that should be committed in the same step are staged, the `git commit` command will create a local snapshot of the changes. The `-m` suffix and quoted text after the command represent the commit message, i.e., an informative yet brief comment on what changes were performed.

```{bash}
# Examplary commit command
git commit -m 'added title to plot illustrating propensity score overlap'
```

Every time a user makes a commit to create a snapshot of the work, `Git` creates a unique hash (a 40-character string created by a **simple hashing algorithm** \[SHA\]) which can be seen as an "ID" of the snapshot which enables users to comprehend every change made and revert back to any snapshot of the repository. @fig-stage-commit-RStudio-gui illustrates the equivalent steps in RStudio GUI.

If any file(s) in the study repository should not be tracked and hence not be synchronized with the remote repository (e.g., because they include confidential information that should not be visible to others like database credentials), these can be specified in the `.gitignore` file which is typically located in the root directory of the repository. To create a `.gitignore` file, a user can either auto-generate it upon initialization of the repository on GitHub (**Supplementary Figure 2**) or manually add a text file called `.gitignore` to the root directory.

## Synchronize changes with remote repository

### Synchronize local changes to remote (`push`)

To synchronize the local changes, the next step involves the upload of our commits to the remote repository on GitHub via the `push` command.

```{bash}
git push
```

In case we initialized the local repository as described in section @sec-gui-initialization-and-git-clone, a remote was automatically configured. This can be checked via the following command.

```{bash}
git remote -v
```

If there is no remote established yet, this can be retrospectively configured using the following commands.

```{bash}
git remote add origin https://github.com/USER/rwe_study.git
git branch -M main
git push -u origin main
```

This step is not needed if the intention of a researcher is just to keep track of local changes and there is no wish to share code, collaborate with others or work across different systems. However, most of the times researchers use `Git` for the purpose of collaborating on a project as depicted in @fig-collaborate.

### Synchronize remote to local (`pull`)

In case collaborators have also made modification to their local files and pushed them to the remote repository, these changes can be easily synchronized with our local copy via the `pull` command.

```{bash}
git pull
```

Occasionally it can occur that two collaborators made conflicting changes to the same file or even to the same line of code. While Git is generally good at automatically integrating (`merging`) new changes, Git will notify the user to resolve a major conflict by editing the conflicting file if Git cannot automatically determine what is correct (e.g., if one collaborator has made changes to a line of code and the other completely deleted it).

## Tracking changes

One of the main motivations to adhere to this workflow is that in return we get rewarded with a detailed audit trail of changes made to our study files. Probably the best way to visualize and track changes is by browsing the `commit history` on the remote repository. @fig-GitHub-gui_changes illustrates this for the example commit we have previously performed in @sec-stage-and-commit-changes. A similar view for uncommitted changes in the RStudio GUI is also provided in @fig-stage-commit-RStudio-gui.

For completeness, tracking uncommitted changes is also possible via the command line, but usually provides the user with a less intuitive output compared to what is visually provided by RStudio and GitHub.

```{bash}
git diff
```

A complete summary of committed changes with details on the SHA hash, author, email, time and commit messages can be accessed via

```{bash}
git log
```

While there are many more useful `Git` features such as `branching` (see **Supplementary Material**), the workflow of staging, committing and pushing/pulling (@fig-workflow) may already suffice for the majority of pharmacoepidemiologists.

## Keeping track of R software versions and paths

A major advantage of modern programming languages, is that they provide a large pool of open-source packages. Packages are compilations of functions that automate frequently used procedures (e.g., querying new user cohorts[@tidyverse] or propensity score matching[@MatchIt]) which expedites the implementation of RWE studies, mitigates copy-paste errors and makes code much more friendly to read and review.

A further step to improve reproducibility when using the R programming language is to ensure that anyone, intending to reproduce analytic results from a `Git` repository, is able to work off the same R package versions and dependencies without having to perform manual installations or path adjustments. These requirements are nothing exclusive to R, but apply to any type of programming language.

### Reproducible R computing environments

One way to achieve this is through self-contained computing environments via Docker images which are isolated and standardized environments which include everything needed to run and deploy applications and code regardless of a user's local operating system.[@boettiger2017a; @nüst2020] Another more lightweight, yet effective way is by using the `renv` R package[@renv], which helps creating **re**producible **env**ironments and manages R package dependencies for a given project. Through a lockfile, the `renv` package keeps track of the underlying version of R that is being used as well as all R packages, their versions and the installation source (e.g., <https://cran.r-project.org/>). To synchronize the R environment with that of a collaborator, e.g., after cloning a repository, the only step to necessary is running the following command in R.

```{r}
renv::restore()
```

Appending the session info to the end of an R script can provide further context about the dependencies and versions of an analytic script.

```{r}
sessionInfo()
```

### Absolute versus relative paths

Another common issue when trying to reproduce analytic code is the use of absolute paths such as in the following example, where we try to call an `icd_code` file from the project's `protocol` sub-directory.

```{r}
icd_codes <- read.csv('C:/User/Projects/rwe_study/protocol/icd_codes.csv')
```

The use of absolute paths will make it impossible for any collaborator to run the code without having to manually adapt every single path throughout a repository which is tedious and time consuming. A better solution to this is the use of relative paths. A popular R package to implement this is the `here` package which enables file referencing in project-oriented workflows. The main function "`here"` creates paths relative to the top-level of the project directory (in our example the `rwe_study` directory). Applied to our example project, the following command would automatically reference the correct path and could be used without modification by any user re-running this script.

```{r}
library(here)
icd_codes <- read.csv(here("data", "icd_codes.csv"))
```

# Discussion

In this practical tutorial, we introduced basic concepts of VCS for transparent and reproducible workflows and gave technical step-by-step instructions for the implementation using `Git` and R. We discussed frequently occurring challenges for reproducibility and how these can be overcome.

`Git` is a powerful tool that perfectly integrates into workflows of quantitative disciplines handling analytic code. It further provides features that make it convenient for project-oriented setups and collaboration at scale. This tutorial is by no means comprehensive as `Git` provides a vast amount of additional features which were not addressed in this manuscript. To get familiar with more advanced `Git` usage, we compiled a non-exhaustive list of further suggested readings and resources in the **Supplementary Material**.

`Git` was primarily designed to work with source code files and works best for plain, text-based documents such as programming code, rich text format (RTF), Markdown or LaTex files. There are limitations when it comes to tracking binary files like Word (.docx) and Excel (.xlsx) as these need to be interpreted by a program or a hardware processor.[@blischak2016] While it can be still useful to track versions of these file types using `Git`, it is important to recognize that modifications in such documents can't be easily inspected using RStudio or GitHub.

Moreover, when working with remote repositories, it is of utmost importance to ensure that sensitive information (such as passwords or patient-level data) are not accidentally shared. To prevent this, we recommend specifying such files in the `.gitignore` file before making the first commit or, more preferably, not storing them in the project directory in the first place.

Despite the potential initial complexities to get acquanited with the `Git` workflow, distributed VCS and code sharing provide unique advantages, such as a full audit trail of which changes were made by whom, when and why. Git makes it easier for users to go back to any snapshot and resolve errors more efficiently. Further, remote repositories are ideal platforms to deploy and archive scripts and documents, facilitate collaboration and make it very convenient to share code. Although data sharing is unfortunately often prohibited due to privacy and legal reasons, many databases have been mapped to common data models like OMOP[@ohdsi2019book] which makes shared code interoperable even without direct access to the raw data. Finally, code sharing can enable researchers to learn from each other, build trust[@orsini2020], expedite the uptake of novel methodologies and knowledge exchange and decrease unneccesary redundancies through sharing of code libraries, functions and algorithms.

{{< pagebreak >}}

# References {.unnumbered}

::: {#refs}
:::

{{< pagebreak >}}

# Figures {.unnumbered}

```{r}
#| label: fig-RStudio-gui
#| fig-cap: "Steps to clone a remote repository using the RStudio graphical user interface."
#| eval: true
#| echo: false
#| out-width: 50%
knitr::include_graphics(here::here("figures", "Figure_1_RStudio_init.png"))
```

{{< pagebreak >}}

```{r}
#| label: fig-structure
#| fig-cap: "Minimal example of a transparent repository structure containing relevant study documents"
#| eval: true
#| echo: false
#| out-width: 60%
knitr::include_graphics(here::here("figures", "Figure_2_repo_structure.png"))
```

{{< pagebreak >}}

```{r}
#| label: fig-workflow
#| fig-cap: "Overview of a basic Git workflow."
#| eval: true
#| echo: false
knitr::include_graphics(here::here("figures", "Figure_3_workflow.png"))
```

{{< pagebreak >}}

```{r}
#| label: fig-stage-commit-RStudio-gui
#| fig-cap: "RStudio provides a graphical user interface as an alternative to command line prompts to interact with Git and to perform command equivalent to git add, git commit and git push/pull (red circles). This view can be accessed in the right upper pane of RStudio under Git > Diff. In this example, an R script with the title '03_propensity_score_analysis.R' is selected and staged. All changes performed in this file can be viewed in the window below with green highlighted lines indicating additions and red highlighted lines deletions from the prior version. In this case, a title was added to a propensity score plot which is also expressed in the commit message."
#| eval: true
#| echo: false
knitr::include_graphics(here::here("figures", "Figure_4_stage_commit.png"))
```

{{< pagebreak >}}

```{r}
#| label: fig-collaborate
#| fig-cap: "Git in connection with remote repositories (e.g., GitHub or GitLab) can signficantly improve collaboration across project members."
#| eval: true
#| echo: false
knitr::include_graphics(here::here("figures", "Figure_5_collaboration.png"))
```

{{< pagebreak >}}

```{r}
#| label: fig-GitHub-gui_changes
#| fig-cap: "Remote repositories like GitHub provide tools to visually track changes made to analytical code and corresponding output such as figures. This commit history illustrates details about the commit (e.g., commit SHA hash and message), a side-by-side comparison of the previous (upper left) and modified (upper right) version of the figure and the corresponding changes made to the R code (bottom)."
#| eval: true
#| echo: false
#| out-width: 105%

knitr::include_graphics(here("figures", "Figure_6_commit_Github_gui.png"))
```
